# -*- coding: utf-8 -*-
"""Gradientpaper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SFJtyoK-MbmV8pxdcaW8guz8g-umD1-0
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import statistics
import argparse
import math

def weightfun(img,mag,ori,i,j,p,q,k1):
    alpha = 1./mag[p][q] 
    beta = 2.*(ori[i][j]-ori[p][q])
    return ((math.cos(beta)+1)*alpha)

def smoothchannel(img,k,mag,ori):
    fin_img = np.copy(img)
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            up = i - k // 2
            left = j - k // 2
            down = i + k // 2 + 1
            right = j + k // 2 + 1
            sum_weights = 0
            result = 0
            for s in range(up, down):
                if s < 0 or s >= img.shape[0]:
                    continue
                for t in range(left, right):
                    if t < 0 or t >= img.shape[1]:
                        continue
                    if mag[s][t] == .0:
                        continue
                    if s != i or t != j:
                        p = s
                        q = t
                        weight = weightfun(img,mag,ori,i,j,p,q,k)
                    else:
                        weight = 1.
                    result += weight * img[s][t]
                    sum_weights += weight
            if sum_weights != 0:
                fin_img[i][j] = round(result / sum_weights)
    return (fin_img).astype(np.uint8)
    
def gradient_analysis(img, k):
    fin_img = np.zeros((img.shape))
    mag = np.zeros((img.shape[0],img.shape[1]))
    ori = np.zeros((img.shape[0],img.shape[1]))
    for ii in range(3):
        temp_img = img[:,:,ii]
        mag = np.zeros((img.shape[0],img.shape[1]))
        ori = np.zeros((img.shape[0],img.shape[1]))
        for y in range(temp_img.shape[0]):
            for x in range(temp_img.shape[1]):
                if(0<x<temp_img.shape[1]-1 and 0<y<temp_img.shape[0]-1):
                    gx = int(temp_img[y][x-1])-int(temp_img[y][x+1])
                    gy = int(temp_img[y+1][x])-int(temp_img[y-1][x]) 
                    mag[y][x] = math.sqrt(gx*gx+gy*gy)
                    ori[y][x] = math.atan2(gx, gy)
        fin_img[:,:,ii] = smoothchannel(temp_img,k,mag,ori)
    return fin_img.astype(np.uint8)

img=cv2.imread('/content/0001.png',1)
import random
img = cv2.cvtColor(cv2.imread('/content/0001.png'),cv2.COLOR_BGR2RGB)
plt.imshow(img)
def sp_noise(image,prob):
    '''
    Add salt and pepper noise to image
    prob: Probability of the noise
    '''
    output = np.zeros(image.shape,np.uint8)
    thres = 1 - prob 
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            rdn = random.random()
            if rdn < prob:
                output[i][j] = 0
            elif rdn > thres:
                output[i][j] = 255
            else:
                output[i][j] = image[i][j]
    return output

noise_img = sp_noise(img,0.05)
cv2.imwrite('sp_noise.jpg', noise_img)
k = 5
fin_img = gradient_analysis(noise_img,k)
plt.figure(figsize=[10,10])
plt.subplot(2,2,1)
plt.imshow(noise_img)
plt.subplot(2,2,2)
plt.imshow(fin_img)
k = 10
fin_img = gradient_analysis(noise_img,k)
plt.subplot(2,2,3)
plt.imshow(fin_img)
k = 15
fin_img = gradient_analysis(noise_img,k)
plt.subplot(2,2,4)
plt.imshow(fin_img)

img=cv2.imread('/content/0001.png',1)
import random
img = cv2.cvtColor(cv2.imread('/content/0001.png'),cv2.COLOR_BGR2RGB)
plt.imshow(img)
def gauss_noise(img):
  gauss = np.random.normal(0,1,img.size)
  gauss = gauss.reshape(img.shape[0],img.shape[1],img.shape[2]).astype('uint8')
  noise = img + img * gauss
  return noise

noise_img = gauss_noise(img)
cv2.imwrite('gauss_noise.jpg', noise_img)
k = 5
fin_img = gradient_analysis(noise_img,k)
plt.figure(figsize=[10,10])
plt.subplot(2,2,1)
plt.imshow(noise_img)
plt.subplot(2,2,2)
plt.imshow(fin_img)
k = 10
fin_img = gradient_analysis(noise_img,k)
plt.subplot(2,2,3)
plt.imshow(fin_img)
k = 15
fin_img = gradient_analysis(noise_img,k)
plt.subplot(2,2,4)
plt.imshow(fin_img)

poissonNoise = np.random.poisson(img).astype(float)
noisyImage = img + poissonNoise
noisyImage=noisyImage.astype(int)
k = 5
fin_img = gradient_analysis(noisyImage,k)
plt.figure(figsize=[10,10])
plt.subplot(2,2,1)
plt.imshow(noisyImage)
plt.subplot(2,2,2)
plt.imshow(fin_img)
k = 10
fin_img = gradient_analysis(noisyImage,k)
plt.subplot(2,2,3)
plt.imshow(fin_img)
k = 15
fin_img = gradient_analysis(noisyImage,k)
plt.subplot(2,2,4)
plt.imshow(fin_img)

img=cv2.imread('/content/0001.png',1)
row,col,ch = img.shape
gauss = np.random.randn(row,col,ch)
gauss = gauss.reshape(row,col,ch)        
noisy = img + img * gauss
noisy=noisy.astype(int)
k = 5
fin_img = gradient_analysis(noisy,k)
plt.figure(figsize=[10,10])
plt.subplot(2,2,1)
plt.imshow(noisy)
plt.subplot(2,2,2)
plt.imshow(fin_img)
k = 10
fin_img = gradient_analysis(noisy,k)
plt.subplot(2,2,3)
plt.imshow(fin_img)
k = 15
fin_img = gradient_analysis(noisy,k)
plt.subplot(2,2,4)
plt.imshow(fin_img)

import time
img=cv2.imread('/content/0001.png',1)
total=[]
sizes=[]
k=5
for i in range(5,15):
  img = cv2.resize(img, (2**i, 2**i))
  lamb_base = 5**2
  sigma = 255 *0.15
  T = 1
  t0 = time.time()
  u1 = gradient_analysis(img,k)
  t1 = time.time()
  total.append(t1-t0)
  sizes.append(2**i)
plt.plot(sizes,total)

plt.plot(sizes,total)

import time
img=cv2.imread('/content/0001.png',1)
img = cv2.resize(img, (32,32))
total=[]
sizes=[]
for i in range(5,16,2):
  lamb_base = 5**2
  sigma = 255 *0.15
  t0 = time.time()
  u1 = gradient_analysis(img,i)
  t1 = time.time()
  total.append(t1-t0)
  sizes.append(i)
plt.plot(sizes,total)