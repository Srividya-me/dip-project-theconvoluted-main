# -*- coding: utf-8 -*-
"""Gradient.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SFJtyoK-MbmV8pxdcaW8guz8g-umD1-0
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import statistics
import argparse
import math

def weightfun(img,mag,ori,i,j,p,q,k1):
    alpha = 1./mag[p][q] 
    beta = 2.*(ori[i][j]-ori[p][q])
    return ((math.cos(beta)+1)*alpha)

def smoothchannel(img,k,mag,ori):
    fin_img = np.copy(img)
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            up = i - k // 2
            left = j - k // 2
            down = i + k // 2 + 1
            right = j + k // 2 + 1
            sum_weights = 0
            result = 0
            for s in range(up, down):
                if s < 0 or s >= img.shape[0]:
                    continue
                for t in range(left, right):
                    if t < 0 or t >= img.shape[1]:
                        continue
                    if mag[s][t] == .0:
                        continue
                    if s != i or t != j:
                        p = s
                        q = t
                        weight = weightfun(img,mag,ori,i,j,p,q,k)
                    else:
                        weight = 1.
                    result += weight * img[s][t]
                    sum_weights += weight
            if sum_weights != 0:
                fin_img[i][j] = round(result / sum_weights)
    return (fin_img).astype(np.uint8)
    
def gradient_analysis(img, k):
    fin_img = np.zeros((img.shape))
    mag = np.zeros((img.shape[0],img.shape[1]))
    ori = np.zeros((img.shape[0],img.shape[1]))
    for ii in range(3):
        temp_img = img[:,:,ii]
        mag = np.zeros((img.shape[0],img.shape[1]))
        ori = np.zeros((img.shape[0],img.shape[1]))
        for y in range(temp_img.shape[0]):
            for x in range(temp_img.shape[1]):
                if(0<x<temp_img.shape[1]-1 and 0<y<temp_img.shape[0]-1):
                    gx = int(temp_img[y][x-1])-int(temp_img[y][x+1])
                    gy = int(temp_img[y+1][x])-int(temp_img[y-1][x]) 
                    mag[y][x] = math.sqrt(gx*gx+gy*gy)
                    ori[y][x] = math.atan2(gx, gy)
        fin_img[:,:,ii] = smoothchannel(temp_img,k,mag,ori)
    return fin_img.astype(np.uint8)

img=cv2.cvtColor(cv2.imread('/content/0001_gaussian.png'),cv2.COLOR_BGR2RGB)
k=11
filtered=gradient_analysis(img,k)
plt.imshow(filtered)

img=cv2.cvtColor(cv2.imread('/content/0001_laplacian.png'),cv2.COLOR_BGR2RGB)
k=11
filtered=gradient_analysis(img,k)
plt.imshow(filtered)

img=cv2.cvtColor(cv2.imread('/content/0001_multiplicative_gaussian.png'),cv2.COLOR_BGR2RGB)
k=11
filtered=gradient_analysis(img,k)
plt.imshow(filtered)

img=cv2.cvtColor(cv2.imread('/content/0001_uniform.png'),cv2.COLOR_BGR2RGB)
k=11
filtered=gradient_analysis(img,k)
plt.imshow(filtered)

img=cv2.cvtColor(cv2.imread('/content/0001_impulse.png'),cv2.COLOR_BGR2RGB)
k=11
filtered=gradient_analysis(img,k)
plt.imshow(filtered)

img=cv2.cvtColor(cv2.imread('/content/0001_poisson.png'),cv2.COLOR_BGR2RGB)
k=11
filtered=gradient_analysis(img,k)
plt.imshow(filtered)

import time
img=cv2.imread('/content/0001.png',1)
total=[]
sizes=[]
k=5
for i in range(5,15):
  img = cv2.resize(img, (2**i, 2**i))
  lamb_base = 5**2
  sigma = 255 *0.15
  T = 1
  t0 = time.time()
  u1 = gradient_analysis(img,k)
  t1 = time.time()
  total.append(t1-t0)
  sizes.append(2**i)
plt.plot(sizes,total)

plt.plot(sizes,total)

import time
img=cv2.imread('/content/0001.png',1)
img = cv2.resize(img, (32,32))
total=[]
sizes=[]
for i in range(5,16,2):
  lamb_base = 5**2
  sigma = 255 *0.15
  t0 = time.time()
  u1 = gradient_analysis(img,i)
  t1 = time.time()
  total.append(t1-t0)
  sizes.append(i)
plt.plot(sizes,total)